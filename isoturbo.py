# -*- coding: utf-8 -*-
"""
Created on Mon May 12 09:31:54 2014

@author: tsaad
"""
import multiprocessing as mp
import numpy as np
import time
from numpy import sin, cos, sqrt, ones, zeros, pi, arange
from numpy import linalg as LA
from fileformats import FileFormats

#------------------------------------------------------------------------------

def compute_turbulence(nthread,xc,yc,zc,psi,um,kx,ky,kz,sxm,sym,szm,nx,ny,nz,ip,jp,kp, q):
  print 'Generating turbulence on thread:', nthread
  t0 = time.time()
  u_ = zeros([nx,ny,nz])
  v_ = zeros([nx,ny,nz])
  w_ = zeros([nx,ny,nz])  
  xoffset = (ip-1)*nx
  yoffset = (jp-1)*ny
  zoffset = (kp-1)*nz
  for k in range(0,nz):
    for j in range(0,ny):
      for i in range(0,nx):
        #for every grid point (i,j,k) do the fourier summation 
        x0 = i + xoffset
        y0 = j + yoffset
        z0 = k + zoffset
        arg = kx*xc[x0] + ky*yc[y0] + kz*zc[z0] + psi
        bm = 2.0*um*cos(arg)
        u_[i,j,k] = np.sum(bm*sxm)
        v_[i,j,k] = np.sum(bm*sym) 
        w_[i,j,k] = np.sum(bm*szm)
  t1 = time.time()
  print 'Thread ', nthread, ' done generating turbulence in ', t1 - t0, 's'
  q.put((ip,jp,kp,u_,v_,w_))
  return ip, jp, kp, u_, v_, w_

#def writefile(filename,velcomponent,nx,ny,nz,dx,dy,dz,patches,array,fileformat):
#  t0 = time.time()  
#  f = open(filename , 'w')
#  zo=[0,0,0]
#  if(velcomponent=='x'):
#    zo=[0,1,1]
#  elif(velcomponent=='y'):
#    zo=[1,0,1]
#  else:
#    zo=[1,1,0]
##  for nt in range(len(array)):    
##    ip,jp,kp = patches[nt]
##    u = array[nt]
##    xlo = (ip-1)*nx*dx + zo[0]*dx/2.0
##    ylo = (jp-1)*ny*dy + zo[1]*dy/2.0
##    zlo = (kp-1)*nz*dz + zo[2]*dz/2.0
##    for k in range(0,nz):
##      for j in range(0,ny):
##        for i in range(0,nx):
##          x = xlo + i*dx
##          y = ylo + j*dy
##          z = zlo + k*dz
##          uu = u[i,j,k]              
##          f.write('%.16f %.16f %.16f %.16f \n' % (x,y,z,uu))        
#    
#  # loop over the velocity fields generated by each thread
#  if (fileformat == FileFormats.XYZ):    
#    f.write('%s \n' % 'XYZ')
#    for nt in range(len(array)):    
#      ip,jp,kp = patches[nt]
#      u = array[nt]
#      xlo = (ip-1)*nx*dx + zo[0]*dx/2.0
#      ylo = (jp-1)*ny*dy + zo[1]*dy/2.0
#      zlo = (kp-1)*nz*dz + zo[2]*dz/2.0
#      for k in range(0,nz):
#        for j in range(0,ny):
#          for i in range(0,nx):
#            x = xlo + i*dx
#            y = ylo + j*dy
#            z = zlo + k*dz
#            uu = u[i,j,k]              
#            f.write('%.16f %.16f %.16f %.16f \n' % (x,y,z,uu))        
#  elif (fileformat == FileFormats.IJK):
#    f.write('%s \n' % 'IJK')    
#    for nt in range(len(array)):    
#      ip,jp,kp = patches[nt]
#      u = array[nt]
#      xlo = (ip-1)*nx*dx + zo[0]*dx/2.0
#      ylo = (jp-1)*ny*dy + zo[1]*dy/2.0
#      zlo = (kp-1)*nz*dz + zo[2]*dz/2.0
#      for k in range(0,nz):
#        for j in range(0,ny):
#          for i in range(0,nx):
#            x = (ip-1)*nx + i
#            y = (jp-1)*ny + j
#            z = (kp-1)*nz + k
#            uu = u[i,j,k]              
#            f.write('%d %d %d %.16f \n' % (x,y,z,uu))
#  else:
#    f.write('%s \n' % 'FLAT')
#    f.write('%d %d %d \n' % (2*nx, 2*ny, 2*nz))
#    for nt in range(len(array)):    
#      u = array[nt]
#      for k in range(0,nz):
#        for j in range(0,ny):
#          for i in range(0,nx):
#            uu = u[i,j,k]              
#            f.write('%.16f\n' % uu)        
#  f.close()
#  t1 = time.time()
#  print 'Done writing to disk in ', t1 - t0, 's'  

#------------------------------------------------------------------------------

def writefile(filename,velcomponent,dx,dy,dz,velarray,fileformat):
  t0 = time.time()  

  nx = len(velarray[:,0,0])
  ny = len(velarray[0,:,0])
  nz = len(velarray[0,0,:])  
  
  f = open(filename , 'w')
  zo=[0,0,0]
  if(velcomponent=='x'):
    zo=[0,1,1]
  elif(velcomponent=='y'):
    zo=[1,0,1]
  else:
    zo=[1,1,0]
    
  # loop over the velocity fields generated by each thread
  if (fileformat == FileFormats.XYZ):    
    f.write('%s \n' % 'XYZ')
    xlo = zo[0]*dx/2.0
    ylo = zo[1]*dy/2.0
    zlo = zo[2]*dz/2.0
    for k in range(0,nz):
      for j in range(0,ny):
        for i in range(0,nx):
          x = xlo + i*dx
          y = ylo + j*dy
          z = zlo + k*dz
          u = velarray[i,j,k]              
          f.write('%.16f %.16f %.16f %.16f \n' % (x,y,z,u))        
  elif (fileformat == FileFormats.IJK):
    f.write('%s \n' % 'IJK')    
    for k in range(0,nz):
      for j in range(0,ny):
        for i in range(0,nx):
          u = velarray[i,j,k]              
          f.write('%d %d %d %.16f \n' % (i,j,k,u))
  else:
    f.write('%s \n' % 'FLAT')
    f.write('%d %d %d \n' % (nx, ny, nz))
    for k in range(0,nz):
      for j in range(0,ny):
        for i in range(0,nx):
          u = velarray[i,j,k]              
          f.write('%.16f\n' % u)        
  f.close()
  t1 = time.time()
  print 'Done writing to disk in ', t1 - t0, 's' 
  
#------------------------------------------------------------------------------
  
def generate_isotropic_turbulence(lx,ly,lz,nx,ny,nz,nmodes,wn1,especf,computeMean,enableIO, fileformat):
  ## grid generation
  # generate cell centered x-grid
  dx = lx/nx
  xc = dx/2.0 + arange(0,nx)*dx
  
  # generate cell centered y-grid
  dy = ly/ny
  yc = dy/2 + arange(0,ny)*dy
  
  # generate cell centered z-grid
  dz = lz/nz
  zc = dz/2 + arange(0,nz)*dz # cell centered coordinates
  
  ## START THE FUN!
  # compute random angles
  phi =   2.0*pi*np.random.uniform(0.0,1.0,nmodes);
  nu = np.random.uniform(0.0,1.0,nmodes);
  theta = np.arccos(2.0*nu -1.0);
  psi   = 2.0*pi*np.random.uniform(0.0,1.0,nmodes);
  mu = np.random.uniform(0.0,1.0,nmodes);  
  alfa = np.arccos(2.0*mu -1.0);
#  alfa  = 2.0*pi*np.random.uniform(0.0,1.0,nmodes);
  
  # highest wave number that can be represented on this grid (nyquist limit)
  wnn = max(np.pi/dx, max(np.pi/dy, np.pi/dz));
  print 'I will generate data up to wave number: ', wnn
  
  # wavenumber step
  dk = (wnn-wn1)/nmodes
  
  # wavenumber at cell centers
  wn = wn1 + 0.5*dk + arange(0,nmodes)*dk

  dkn = ones(nmodes)*dk
  
  #   wavenumber vector from random angles   
  kx = sin(theta)*cos(phi)*wn
  ky = sin(theta)*sin(phi)*wn
  kz = cos(theta)*wn
  
  # sigma is the unit direction which gives the direction of the synthetic
  # velocity field
  sxm = cos(phi)*cos(theta)*cos(alfa) - sin(phi)*sin(alfa)
  sym = sin(phi)*cos(theta)*cos(alfa) + cos(phi)*sin(alfa)
  szm = -sin(theta)*cos(alfa)   
  
  # alternative ways of computing sigma:
#  sxm = cos(phi)*cos(theta)*cos(alfa) - sin(phi)*sin(alfa)*cos(theta);
#  sym = sin(phi)*cos(theta)*cos(alfa) + cos(phi)*sin(alfa)*cos(theta);
#  szm = -sin(theta)*cos(alfa);   

#  sxm = cos(theta)*cos(alfa)
#  sym = cos(theta)*sin(alfa)
#  szm = -sin(theta)*cos(phi)*cos(alfa)-sin(theta)*sin(phi)*sin(alfa)

  # verify that the wave vector and sigma are perpendicular
  kk = kx*sxm + ky*sym + kz*szm;
  print 'Orthogonality of k and sigma (divergence in wave space): ', LA.norm(kk)
  
  # get the modes   
  km = sqrt(kx*kx + ky*ky + kz*kz)
  
  # now create an interpolant for the spectrum. this is needed for
  # experimentally-specified spectra
  espec = especf(km)   # use interpolation function returned by `interp1d`
  espec = espec.clip(0.0) # make sure that the lower end of the spectrum is clipped at 0
      
  # generate turbulence at cell centers
  print 'Now generating turbulence...'
  um = sqrt(espec*dkn)
      
  #  must use Manager queue here, or will not work
  nthreads = 2;
  nxt = nx/nthreads;
  nyt = nx/nthreads;
  nzt = nx/nthreads;
  
  manager = mp.Manager()
  mq = manager.Queue()    
  pool = mp.Pool(mp.cpu_count()*2) #assume 2 threads per core

  #fire off workers
  jobs = []
  nthread = 0
  for k in range(1,nthreads+1):
    for j in range(1,nthreads+1):
      for i in range(1,nthreads+1):
        nthread= nthread+1
        job = pool.apply_async(compute_turbulence, (nthread,xc,yc,zc,psi,um,kx,ky,kz,sxm,sym,szm,nxt,nyt,nzt,i,j,k,mq))
        jobs.append(job)
        
  # collect results from the workers through the pool result queue
  print 'now collecting results from individual threads...'
  uarrays = []
  varrays = []
  warrays = []
  patches = []
  for job in jobs: 
    i,j,k,u,v,w  = job.get()
    uarrays.append(u)
    varrays.append(v)
    warrays.append(w)
    patches.append([i,j,k])
  del u, v, w
  
  pool.terminate()
  pool.close()

  #combine the arrays computed from threads into large arrays
  print 'now combining velocity fields generated by the individual threads...'
  uall=zeros([nx,ny,nz])
  vall=zeros([nx,ny,nz])
  wall=zeros([nx,ny,nz])
  nthread = 0
  for k in range(1,nthreads+1):
    for j in range(1,nthreads+1):
      for i in range(1,nthreads+1):
        uall[(i-1)*nxt:i*nxt,(j-1)*nyt:j*nyt,(k-1)*nzt:k*nzt] = uarrays[nthread]
        vall[(i-1)*nxt:i*nxt,(j-1)*nyt:j*nyt,(k-1)*nzt:k*nzt] = varrays[nthread]
        wall[(i-1)*nxt:i*nxt,(j-1)*nyt:j*nyt,(k-1)*nzt:k*nzt] = warrays[nthread]
        nthread=nthread+1
  
  #now create three new threads, each
  if enableIO:
    print 'Writing to disk. This may take a while...'
    writeufile = mp.Process(target=writefile, args=('u_'+str(nx)+'.txt','x',dx,dy,dz,uall, fileformat))
    writeufile.start()
    
    writevfile = mp.Process(target=writefile, args=('v_'+str(nx)+'.txt','y',dx,dy,dz,vall, fileformat))
    writevfile.start()
    
    writewfile = mp.Process(target=writefile, args=('w_'+str(nx)+'.txt','z',dx,dy,dz,wall, fileformat))
    writewfile.start()
    
    writeufile.join()
    writevfile.join()
    writewfile.join()
  return uall,vall,wall